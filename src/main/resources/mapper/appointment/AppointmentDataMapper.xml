<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.scenic.mapper.appointment.AppointmentDataMapper">

    <!-- 获取入园预约数据（个人 + 团队预约聚合） -->
    <select id="getEnterReservationData" resultType="java.util.Map">
        <!-- 当预约功能都关闭时，返回空结果集 -->
        <if test="individualReserveStatus != 1 and teamReserveStatus != 1">
            SELECT 
                DATE(NOW()) AS reserve_date,
                '预约功能已关闭' AS reserve_status,
                0 AS booked_count,
                0 AS total_limit,
                FALSE AS is_open
            WHERE 1 = 0  -- 返回空结果集
        </if>
        
        <!-- 步骤1：聚合个人预约数据 -->
        <if test="individualReserveStatus == 1">
            SELECT
                DATE(r.visit_date) AS reserve_date,  -- 预约日期
                CASE 
                    WHEN p.is_closed = 1 THEN '不开放'  -- 优先判断日期是否闭园
                    WHEN SUM(r.total_count) >= #{dailyLimit} THEN '已满'  -- 对比单日上限
                    ELSE CONCAT('已预约', SUM(r.total_count), '/', #{dailyLimit}) 
                END AS reserve_status,
                SUM(r.total_count) AS booked_count,
                #{dailyLimit} AS total_limit,
                (p.is_closed = 0 AND p.day_type = 0) AS is_open  -- 只有在开放且为工作日时才开放预约
            FROM
                individual_reservation r
            LEFT JOIN park_open_time_config p ON DATE(r.visit_date) = p.config_date
            WHERE
                r.deleted = 0  -- 排除逻辑删除记录
                AND r.status NOT IN (1, 11)  -- 排除已取消、已过期记录
                -- 筛选指定年月的数据
                AND YEAR(r.visit_date) = #{year}
                AND MONTH(r.visit_date) = #{month}
            GROUP BY
                DATE(r.visit_date), p.is_closed, p.day_type
        </if>
            
        <if test="individualReserveStatus == 1 and teamReserveStatus == 1">
            UNION ALL
        </if>
        
        <!-- 步骤2：聚合团队预约数据（与个人预约逻辑一致） -->
        <if test="teamReserveStatus == 1">
            SELECT
                DATE(t.appointment_date) AS reserve_date,
                CASE 
                    WHEN p.is_closed = 1 THEN '不开放'
                    WHEN SUM(t.team_size) >= #{dailyLimit} THEN '已满'
                    ELSE CONCAT('已预约', SUM(t.team_size), '/', #{dailyLimit})
                END AS reserve_status,
                SUM(t.team_size) AS booked_count,
                #{dailyLimit} AS total_limit,
                (p.is_closed = 0 AND p.day_type = 0) AS is_open  -- 只有在开放且为工作日时才开放预约
            FROM
                team_appointment t
            LEFT JOIN park_open_time_config p ON DATE(t.appointment_date) = p.config_date
            WHERE
                t.status != 0  -- 排除已取消记录
                -- 筛选指定年月的数据
                AND YEAR(t.appointment_date) = #{year}
                AND MONTH(t.appointment_date) = #{month}
            GROUP BY
                DATE(t.appointment_date), p.is_closed, p.day_type
        </if>
            
        <!-- 步骤3：合并后按日期排序，确保日历展示顺序正确 -->
        <if test="individualReserveStatus == 1 or teamReserveStatus == 1">
            ORDER BY reserve_date
        </if>
    </select>
    
    <!-- 获取活动预约数据 -->
    <select id="getActivityReservationData" resultType="java.util.Map">
        <!-- 步骤1：仅统计main_config中开放的活动预约 -->
        SELECT
            DATE(a.registration_time) AS reserve_date,  -- 活动预约日期
            a.activity_title AS activity_name,          -- 活动名称
            -- 假设活动表（activity）存储活动人数上限，通过子查询获取
            (SELECT team_limit FROM activity WHERE id = a.activity_id) AS activity_limit,
            COUNT(a.id) AS booked_count,
            CASE 
                WHEN p.is_closed = 1 THEN '不开放'  -- 日期闭园则不开放
                WHEN COUNT(a.id) >= (SELECT CAST(team_limit AS UNSIGNED) FROM activity WHERE id = a.activity_id) THEN '已满'  -- 对比活动上限
                ELSE CONCAT('已预约', COUNT(a.id), '/', (SELECT team_limit FROM activity WHERE id = a.activity_id))
            END AS reserve_status,
            (p.is_closed = 0 AND p.day_type = 0) AS is_open  -- 只有在开放且为工作日时才开放预约
        FROM
            activity_registration a
        LEFT JOIN park_open_time_config p ON DATE(a.registration_time) = p.config_date
        WHERE
            a.status != 0  -- 排除已取消记录
            AND #{activityReserveStatus} = 1  -- 活动预约已开放
            -- 筛选指定年月的数据
            AND YEAR(a.registration_time) = #{year}
            AND MONTH(a.registration_time) = #{month}
        GROUP BY
            DATE(a.registration_time), a.activity_title, p.is_closed, p.day_type, a.activity_id
        ORDER BY
            reserve_date, activity_name;
    </select>

</mapper>
