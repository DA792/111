<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.scenic.mapper.appointment.AppointmentDataMapper">

    <!-- 获取入园预约数据（个人 + 团队预约聚合） -->
    <select id="getEnterReservationData" resultType="java.util.Map">
        <!-- 步骤1：聚合个人预约数据 -->
        SELECT
            DATE(r.visit_date) AS reserve_date,  -- 预约日期
            CASE 
                WHEN p.is_closed = 1 THEN '不开放'  -- 优先判断日期是否闭园
                WHEN SUM(r.total_count) >= #{dailyLimit} THEN '已满'  -- 对比单日上限
                ELSE CONCAT('已预约', SUM(r.total_count), '/', #{dailyLimit}) 
            END AS reserve_status,
            SUM(r.total_count) AS booked_count,
            #{dailyLimit} AS total_limit,
            (p.is_closed = 0) AS is_open
        FROM
            individual_reservation r
        LEFT JOIN park_open_time_config p ON DATE(r.visit_date) = p.config_date
        WHERE
            r.deleted = 0  -- 排除逻辑删除记录
            AND r.status NOT IN (1, 11)  -- 排除已取消、已过期记录
            -- 仅统计main_config中开放的个人预约
            AND #{individualReserveStatus} = 1
            -- 筛选指定年月的数据
            AND YEAR(r.visit_date) = #{year}
            AND MONTH(r.visit_date) = #{month}
        GROUP BY
            DATE(r.visit_date), p.is_closed
            
        UNION ALL
        
        <!-- 步骤2：聚合团队预约数据（与个人预约逻辑一致） -->
        SELECT
            DATE(t.appointment_date) AS reserve_date,
            CASE 
                WHEN p.is_closed = 1 THEN '不开放'
                WHEN SUM(t.team_size) >= #{dailyLimit} THEN '已满'
                ELSE CONCAT('已预约', SUM(t.team_size), '/', #{dailyLimit})
            END AS reserve_status,
            SUM(t.team_size) AS booked_count,
            #{dailyLimit} AS total_limit,
            (p.is_closed = 0) AS is_open
        FROM
            team_appointment t
        LEFT JOIN park_open_time_config p ON DATE(t.appointment_date) = p.config_date
        WHERE
            t.status != 0  -- 排除已取消记录
            -- 仅统计main_config中开放的团队预约
            AND #{teamReserveStatus} = 1
            -- 筛选指定年月的数据
            AND YEAR(t.appointment_date) = #{year}
            AND MONTH(t.appointment_date) = #{month}
        GROUP BY
            DATE(t.appointment_date), p.is_closed
            
        -- 步骤3：合并后按日期排序，确保日历展示顺序正确
        ORDER BY reserve_date;
    </select>
    
    <!-- 获取活动预约数据 -->
    <select id="getActivityReservationData" resultType="java.util.Map">
        <!-- 步骤1：仅统计main_config中开放的活动预约 -->
        SELECT
            DATE(a.registration_time) AS reserve_date,  -- 活动预约日期
            a.activity_title AS activity_name,          -- 活动名称
            -- 假设活动表（activity）存储活动人数上限，通过子查询获取
            (SELECT max_participants FROM activity WHERE id = a.activity_id) AS activity_limit,
            COUNT(a.id) AS booked_count,
            CASE 
                WHEN p.is_closed = 1 THEN '不开放'  -- 日期闭园则不开放
                WHEN COUNT(a.id) >= (SELECT max_participants FROM activity WHERE id = a.activity_id) THEN '已满'  -- 对比活动上限
                ELSE CONCAT('已预约', COUNT(a.id), '/', (SELECT max_participants FROM activity WHERE id = a.activity_id))
            END AS reserve_status,
            (p.is_closed = 0) AS is_open
        FROM
            activity_registration a
        LEFT JOIN park_open_time_config p ON DATE(a.registration_time) = p.config_date
        WHERE
            a.status != 0  -- 排除已取消记录
            AND #{activityReserveStatus} = 1  -- 活动预约已开放
            -- 筛选指定年月的数据
            AND YEAR(a.registration_time) = #{year}
            AND MONTH(a.registration_time) = #{month}
        GROUP BY
            DATE(a.registration_time), a.activity_title, p.is_closed, a.activity_id
        ORDER BY
            reserve_date, activity_name;
    </select>

</mapper>
